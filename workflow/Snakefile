from os.path import join
import sys
import os
import pandas as pd
import yaml
import uuid
from pathlib import Path

# no truncations during print pandas data frames
pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
pd.set_option('display.max_colwidth', None)

include: "rules/init.smk"

def get_clear_target_files(runclear):
    targetfiles=[]
    if runclear:
        for s in SAMPLES:
            targetfiles.append(join(WORKDIR,"results",s,"CLEAR","quant.txt"))
            targetfiles.append(join(WORKDIR,"results",s,"CLEAR","quant.txt.annotated"))
    return targetfiles

def get_dcc_target_files(rundcc):
    targetfiles=[]
    if rundcc:
        for s in SAMPLES:
            targetfiles.append(join(WORKDIR,"results",s,"DCC",s+".dcc.counts_table.tsv"))
    return targetfiles

def get_mapsplice_target_files(runmapslice):
    targetfiles=[]
    if runmapslice:
        for s in SAMPLES:
            targetfiles.append(join(WORKDIR,"results",s,"MapSplice","circular_RNAs.txt"))
            targetfiles.append(join(WORKDIR,"results",s,"MapSplice","alignments.bam"))
    return targetfiles

def get_nclscan_target_files(runnclscan):
    targetfiles=[]
    if not os.path.exists(join(WORKDIR,"results")): os.mkdir(join(WORKDIR,"results"))
    if runnclscan==True or runnclscan=="True" or runnclscan=="TRUE":
        for s in SAMPLES:
            if not os.path.exists(join(WORKDIR,"results",s)): os.mkdir(join(WORKDIR,"results",s))
            if not os.path.exists(join(WORKDIR,"results",s,"NCLscan")): os.mkdir(join(WORKDIR,"results",s,"NCLscan"))
            if SAMPLESDF.loc[[s],"PEorSE"][0]=="SE":
                Path(join(WORKDIR,"results",s,"NCLscan",s+".result")).touch() # nclscan cannot run for se 
                with open(join(WORKDIR,"results",s,"NCLscan",s+".nclscan.counts_table.tsv"),'w') as f:
                    f.write("chrom\tend\tstart\tstrand\tread_count\tnclscan_annotation\n") # create empty file
            else:
                targetfiles.append(join(WORKDIR,"results",s,"NCLscan",s+".result"))
    return targetfiles

localrules: multiqc, annotate_clear_output, merge_genecounts

rule all:
    input:
        ## index
        join(REF_DIR,"ref.genes.genepred_w_geneid"),
        join(STAR_INDEX_DIR,"SA"),
        join(REF_DIR,"ref.sa"),
        ## cutadapt
        ## cutadapt files are now temp() to save space
        expand(join(WORKDIR,"results","{sample}","trim","{sample}.R1.trim.fastq.gz"),sample=SAMPLES),
        expand(join(WORKDIR,"results","{sample}","trim","{sample}.R2.trim.fastq.gz"),sample=SAMPLES),
        ## fastqc
        expand(join(WORKDIR,"qc","fastqc","{sample}.R1.trim_fastqc.zip"),sample=SAMPLES),
        ## star1p
        expand(join(WORKDIR,"results","{sample}","STAR1p","{sample}_p1.SJ.out.tab"),sample=SAMPLES),
        ## star 1p outputs required for DCC
        expand(join(WORKDIR,"results","{sample}","STAR1p","{sample}_p1.Chimeric.out.junction"),sample=SAMPLES),
        expand(join(WORKDIR,"results","{sample}","STAR1p","mate1","{sample}"+"_mate1.Chimeric.out.junction"),sample=SAMPLES),
        expand(join(WORKDIR,"results","{sample}","STAR1p","mate2","{sample}"+"_mate2.Chimeric.out.junction"),sample=SAMPLES),
        ## merge junctions
        join(WORKDIR,"results","pass1.out.tab"),
        # ## star2p
        expand(join(WORKDIR,"results","{sample}","STAR2p","{sample}_p2.Chimeric.out.junction"),sample=SAMPLES),
        expand(join(WORKDIR,"results","{sample}","STAR2p","{sample}_p2.Aligned.sortedByCoord.out.bam"),sample=SAMPLES),
        expand(join(WORKDIR,"results","{sample}","STAR2p","{sample}_p2.ReadsPerGene.out.tab"),sample=SAMPLES),
        # ## star gene counts matrix
        join(WORKDIR,"results","stranded_STAR_GeneCounts.tsv"),
        # ## picard MarkDuplicates metrics
        expand(join(WORKDIR,"qc","picard_MarkDuplicates","{sample}.MarkDuplicates.metrics.txt"),sample=SAMPLES),
        # ## BSJ bam
        # expand(join(WORKDIR,"results","{sample}","STAR2p","{sample}.BSJ.bam"),sample=SAMPLES),
        ## alignment stats
        expand(join(WORKDIR,"results","{sample}","STAR2p","alignmentstats.txt"), sample=SAMPLES),
        ## circExplorer --> we run circExplorer2
        expand(join(WORKDIR,"results","{sample}","circExplorer","{sample}.circularRNA_known.txt"),sample=SAMPLES), # annotations with "known" GENCODE genes and NOT "known" circRNAs!
        ## CLEAR quant output --> CLEAR is nothing but circExplorer3
        get_clear_target_files(RUN_CLEAR),
        ## ciri
        expand(join(WORKDIR,"results","{sample}","ciri","{sample}.ciri.out"),sample=SAMPLES),
        ## DCC
        # expand(join(WORKDIR,"results","{sample}","DCC","{sample}.dcc.counts_table.tsv"),sample=SAMPLES),
        get_dcc_target_files(RUN_DCC),
        ## MapSplice
        get_mapsplice_target_files(RUN_MAPSPLICE),
        ## NCLscan
        get_nclscan_target_files(RUN_NCLSCAN),
        ## merged counts per sample table of all counts/annotations from all circRNA callers
        expand(join(WORKDIR,"results","{sample}","{sample}.circRNA_counts.txt"),sample=SAMPLES),
        ## aggregated counts matrix
        # join(WORKDIR,"results","circRNA_counts_matrix.tsv"),
        # ## ciri BSJ bam
        # expand(join(WORKDIR,"results","{sample}","ciri","{sample}.bwa.BSJ.bam"),sample=SAMPLES),
        # ## ciri aggregate count matrix
        # join(WORKDIR,"results","ciri_count_matrix.txt"),
        # ## circExplorer aggregate count matrix
        # join(WORKDIR,"results","circExplorer_count_matrix.txt"),
        # join(WORKDIR,"results","circExplorer_BSJ_count_matrix.txt"),
        # ## BSJ bams and bigwigs
        # expand(join(WORKDIR,"results","{sample}","customBSJs","{sample}.valid_STAR_BSJ.bed"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","customBSJs","{sample}.novel_CIRI_BSJ.bed"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","customBSJs","{sample}.BSJ.bed"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","STAR2p","BSJs","{sample}.BSJ."+HOST+".bam"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","STAR2p","BSJs","{sample}.BSJ."+HOST+".bw"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","STAR2p","BSJs","{sample}.BSJ."+HOST+".plus.bam"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","STAR2p","BSJs","{sample}.BSJ."+HOST+".plus.bw"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","STAR2p","BSJs","{sample}.BSJ."+HOST+".minus.bam"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","STAR2p","BSJs","{sample}.BSJ."+HOST+".minus.bw"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","STAR2p","BSJs","{sample}.BSJ."+HOST+".bed"),sample=SAMPLES),
        # ## Spliced reads bams and bigwigs
        # expand(join(WORKDIR,"results","{sample}","STAR2p","{sample}.spliced_reads."+HOST+".bam"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","STAR2p","{sample}.spliced_reads."+HOST+".bw"),sample=SAMPLES),
        # ## linear reads bams and bigwigs
        # # expand(join(WORKDIR,"results","{sample}","STAR2p","{sample}.linear.bam"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","STAR2p","{sample}.linear_reads."+HOST+".bam"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","STAR2p","{sample}.linear_reads."+HOST+".bw"),sample=SAMPLES),

        # ## CIRI2 and CIRCEXPLORER2 VENN DIAGRAM
        # expand(join(WORKDIR,"results","{sample}","{sample}.venn_mqc.png"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","{sample}.cirionly.lst"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","{sample}.circexploreronly.lst"),sample=SAMPLES),
        # expand(join(WORKDIR,"results","{sample}","{sample}.common.lst"),sample=SAMPLES),
        # ## multiqc report
        # join(WORKDIR,"multiqc_report.html")

include: "rules/create_index.smk"
include: "rules/preprocessing.smk"
include: "rules/qc.smk"
include: "rules/align.smk"
include: "rules/post_align_processing.smk"
include: "rules/findcircrna.smk"
include: "rules/post_findcircrna_processing.smk"








    
    
